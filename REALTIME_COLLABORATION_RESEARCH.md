Colaboración en tiempo real estilo Figma con React Flow y Supabase

Introducción

Implementar colaboración multiplayer avanzada al estilo Figma en una aplicación web es un desafío multidisciplinario. Se requiere sincronizar en tiempo real un canvas de nodos y conexiones (usando React Flow) entre múltiples usuarios, mostrando presencia de usuarios (cursores remotos, avatares, selecciones compartidas e indicadores de quién está viendo qué elemento) y resolviendo conflictos concurrentes sin perder datos. Además, el estado colaborativo debe persistir para que las sesiones se puedan retomar, y todo esto integrado con un sistema de usuarios autenticados (en este caso Supabase proporciona autenticación y base de datos). En esencia, buscamos ofrecer una experiencia tan fluida como la de Figma o Miro, donde varios usuarios editan un diagrama simultáneamente y todos ven los cambios al instante.

Este objetivo trae consigo varios retos técnicos importantes ￼ ￼:
	•	Sincronización en tiempo real: asegurar que las acciones sobre el grafo (mover/agregar/editar nodos y edges) se transmitan a todos los clientes al instante y de forma consistente.
	•	Presencia y colaboración visible: indicar qué usuarios están conectados y dónde están interactuando – por ejemplo mostrando cursores con sus nombres, qué nodo tienen seleccionado o incluso qué área del diagrama están viendo.
	•	Resolución de conflictos concurrentes: permitir ediciones simultáneas sin bloqueos; si dos personas editan algo a la vez, el sistema debe reconciliar los cambios automáticamente, evitando estados inconsitentes o pérdidas de datos.
	•	Persistencia y recuperación de sesión: conservar el estado del diagrama colaborativo en una base de datos (idealmente en Supabase/Postgres) para que si todos se desconectan o en caso de reinicios, el documento no se pierda y se pueda continuar editando más tarde.
	•	Autenticación e integraciones: aprovechar el sistema de usuarios (Supabase Auth u otro) para controlar acceso a sesiones colaborativas (p. ej. permisos de edición/solo lectura) y vincular la presencia a identidades de usuario reales (avatares, nombres).

Afortunadamente, en los últimos años han madurado tecnologías específicas para habilitar esta colaboración en tiempo real de forma robusta. En particular destacan las basadas en CRDTs (Conflict-Free Replicated Data Types), estructuras de datos que permiten fusiones automáticas de cambios concurrentes sin conflictos ￼. Vamos a investigar a fondo varias alternativas modernas que utilizan CRDTs o soluciones similares para lograr estas funcionalidades:
	•	Yjs con Hocuspocus: Yjs es una biblioteca CRDT popular de código abierto, y Hocuspocus un servidor WebSocket especializado para sincronizar documentos Yjs.
	•	Liveblocks: un servicio SaaS que ofrece “colaboración en tiempo real como servicio”, con APIs de estado compartido y presencia ya resueltas.
	•	Automerge + PartyKit: Automerge es otra librería CRDT open source; combinada con PartyKit (plataforma para desplegar lógica en tiempo real en la edge) permite crear un backend a medida para colaboración.
	•	Otras alternativas de presencia/CRDT: exploraremos brevemente otras opciones recientes, como nuevas librerías CRDT (p. ej. Loro), servicios de sincronización en base de datos (Supabase Realtime, Electric SQL) u otros frameworks, evaluando su adecuación.

El reporte evaluará compatibilidad con React Flow, facilidad de integración, capacidades de presencia, rendimiento escalando a múltiples usuarios, persistencia de datos, dificultad de integrar con Supabase, calidad de la documentación/comunidad y ejemplos de uso en producción de cada alternativa. Al final, se proporcionan recomendaciones claras sobre qué tecnología encaja mejor con el stack propuesto (React + React Flow + Supabase) y los requisitos de tipo Figma.

Requisitos de colaboración en tiempo real en React Flow

Antes de comparar soluciones, resumamos las funcionalidades específicas que necesitamos implementar en nuestra aplicación de diagramas con React Flow:
	•	Sincronización de nodos, edges y posiciones: Cualquier cambio en la estructura del diagrama debe propagarse instantáneamente a todos los clientes conectados. Esto incluye crear/eliminar nodos y edges, y actualizar propiedades (por ejemplo, posición de un nodo arrastrado, texto/etiqueta de un nodo, estilo de una conexión, etc.). La sincronización debe ser a baja latencia de manera que múltiples usuarios puedan literalmente ver cómo otro mueve un elemento en tiempo real.
	•	Presencia de usuarios: Debe haber indicadores visuales de la participación de otros usuarios:
	•	Mostrar un avatar o nombre de cada usuario actualmente conectado al documento.
	•	Cursores remotos: cada usuario debería ver el cursor de los demás moviéndose en el canvas, típicamente con su nombre/initiales y color distintivo, tal como ocurre en Figma.
	•	Selección compartida: si un usuario selecciona un nodo o elemento, los demás podrían verlo resaltado con un recuadro de color o una etiqueta con el nombre del usuario (Figma muestra el contorno del objeto en el color del colaborador). Similarmente, al editar texto dentro de un nodo se suele enseñar un cursor de texto con el nombre.
	•	Vistas/Focus: opcionalmente, indicar si otro usuario está enfocando o siguiendo cierto elemento (p. ej. “María está viendo este nodo”). Esto puede ser una pequeña etiqueta emergente cuando otro usuario tiene el cursor sobre un nodo o lo tiene seleccionado.
	•	Edición concurrente sin bloqueos: Todos los usuarios deben poder editar libremente. No queremos un sistema de “lock” rígido donde solo uno puede editar a la vez; en cambio, el sistema debe fusionar cambios concurrentes. Por ejemplo, si dos personas agregan cada una un nodo diferente al mismo tiempo, ambos nodos deben aparecer en el grafo final. Si dos personas editan el mismo atributo exactamente (ej: arrastran el mismo nodo simultáneamente), el sistema debe resolverlo de manera determinística (usualmente el último cambio prevalece en esa propiedad) y lo más importante: mantener a todos sincronizados en un estado consistente.
	•	Indicadores de conflicto o bloqueo suave: Aunque no se bloquea la edición, podría ser útil avisar al usuario de posibles colisiones – por ejemplo, si detectamos que otro usuario está moviendo el mismo nodo, podríamos mostrar su avatar cerca del nodo para disuadir ediciones concurrentes en ese elemento. Este tipo de feedback mejora la usabilidad y evita “pelear por el nodo” sin necesidad de bloquear estrictamente.
	•	Persistencia del estado colaborativo: Los cambios deben persistir más allá de la sesión en memoria. Idealmente, cuando el último usuario cierra el documento, el estado final del diagrama queda guardado (por ejemplo en Supabase/Postgres) para que al reabrirlo más tarde se cargue la última versión. También debería ser posible cargar un documento existente para empezar la colaboración sobre datos ya guardados.
	•	Sesiones y autenticación: Integración con Supabase Auth para que solo usuarios autorizados accedan a ciertos documentos colaborativos. Posibilidad de implementar permisos (ej. algunos usuarios solo visualización, otros edición) aprovechando el sistema de roles o RLS de Supabase. Además, usar los datos de perfil (nombre, foto) para los avatares en presencia.
	•	Rendimiento y escalabilidad: El sistema debe soportar varios usuarios concurrentes sin degradación notable. En un entorno tipo Figma normalmente hay docenas de usuarios como mucho editando simultáneamente un archivo, pero la solución ideal debería escalar incluso a más (50-100 usuarios) manteniendo la sincronización fluida. Igualmente, el tamaño del documento (cantidad de nodos/edges) debe poder crecer (cientos o miles de elementos) sin que la sincronización colapse. La latencia de las actualizaciones debe ser mínima (ideal << 100ms en la mayoría de casos locales).
	•	Facilidad de integración en React/React Flow: Dado que usamos React, es importante que la solución se pueda integrar de forma razonablemente sencilla en el estado de React Flow. Por ejemplo, React Flow nos provee APIs para controlar el estado de los nodos/edges; la solución debería interoperar con este estado (sea reemplazándolo por un estado colaborativo, o sincronizándose con él). Una buena integración podría ser mediante hooks o estado global (p. ej. usando Zustand, context API u otros) que alimenten React Flow.

Teniendo claros estos requerimientos, veamos cómo las distintas alternativas cumplen con ellos.

Tecnologías basadas en CRDT para colaboración en tiempo real

Una estrategia fundamental para lograr edición concurrente sin conflictos es usar CRDTs (Conflict-Free Replicated Data Types). Un CRDT es una estructura de datos diseñada para sistemas distribuidos donde múltiples réplicas pueden recibir actualizaciones independientes y aun así converger en el mismo estado final, sin necesidad de un control centralizado de versiones ￼. A diferencia de las técnicas de Operational Transformation (OT) usadas históricamente en Google Docs, los CRDT no requieren un servidor central que calcule transformaciones; cada cliente puede aplicar cambios de otros en cualquier orden y el resultado será consistente.

En la práctica, librerías como Yjs, Automerge, Loro, etc. implementan distintos tipos de CRDT (para texto, para estructuras JSON, para listas ordenadas, mapas, etc.) proporcionando una interfaz fácil (similar a manipular objetos/arrays normales) pero con “superpoderes”: los cambios locales se propagan a otras instancias y se fusionan automáticamente sin conflictos ￼. Estas librerías manejan internamente la complejidad de identificar cada operación con un timestamp o ID único y mantener un registro de elementos eliminados, etc., de modo que evitan duplicados y conflictos lógicos.

No obstante, un CRDT por sí solo no provee transporte. Es decir, Yjs o Automerge nos dan la lógica de fusión, pero no envían los cambios a otros usuarios por arte de magia – necesitamos un canal de comunicación (WebSockets, WebRTC, etc.) para intercambiar los deltas o actualizaciones entre clientes. Algunas librerías vienen con módulos accesorios o proveedores para transporte, mientras que otras se combinan con servicios externos.

En general, tenemos dos enfoques para agregar colaboración multi-usuario:
	1.	Usar una librería CRDT + implementar/usar un servidor propio: Por ejemplo Yjs con un servidor WebSocket (Hocuspocus u otro), o Automerge con un servicio custom (PartyKit, Socket.io, etc.). Esto ofrece flexibilidad máxima y suele ser open source, pero exige integrar piezas y manejar la infraestructura del servidor.
	2.	Usar un servicio/SDK de terceros de colaboración: Por ejemplo Liveblocks (o Firebase Firestore, Ably, etc.). Estos suelen abstraer tanto la sincronización como la presencia y almacenamiento, a cambio de encajar en su ecosistema (y potencialmente incurrir en costos). Suelen internamente usar CRDT u OT, pero para el desarrollador es transparente.

Ambos enfoques pueden funcionar con React Flow. A continuación, exploraremos en detalle las alternativas concretas propuestas:

Yjs + Hocuspocus

Yjs es una librería CRDT de alto rendimiento para Javascript/TypeScript (también hay implementaciones en otros lenguajes, e.g. Yrs en Rust). Ha ganado popularidad por su eficacia y flexibilidad para distintos casos de uso, desde editores de texto tipo Google Docs hasta diagramas o incluso modelos 3D colaborativos. Yjs expone tipos compartidos como Y.Map, Y.Array, Y.Text, etc., que se comportan como estructuras mutables normales pero que propagan y combinan cambios en tiempo real entre peers ￼. Es network-agnostic, lo que significa que podemos usar distintos medios para sincronizar (WebSocket, WebRTC, protocolos p2p, etc.). También soporta offline editing (los cambios hechos sin conexión se sincronizan al reconectar) y proporciona un mecanismo de undo/redo multinodo bastante potente, ya que conserva suficiente información de las operaciones aplicadas.

Un punto clave de Yjs es que no almacena todo el historial de cambios en memoria una vez aplicados (sí puede guardar snapshots si se requieren). Esto lo hace muy eficiente en uso de memoria y CPU comparado con algunos otros CRDTs. Por ejemplo, se ha señalado que Automerge conserva todos los cambios (incluso elementos borrados) en su estado interno, mientras que Yjs no – por eso Yjs suele usar menos memoria y escalar mejor en documentos grandes ￼. En pruebas con documentos de texto voluminosos, Yjs ha mostrado ser órdenes de magnitud más rápido y ligero que Automerge ￼ ￼ (en parte gracias a su algoritmo incremental optimizado conocido como Yata).

Hocuspocus es un servidor WebSocket diseñado específicamente para Yjs. Desarrollado por el equipo de Tiptap, básicamente implementa el “protocolo de sincronización” de Yjs sobre websockets, manejando la conexión de múltiples clientes a un documento compartido (Y.Doc). En otras palabras, Hocuspocus actúa como un coordinador central: recibe actualizaciones de un documento Yjs de parte de un cliente y las retransmite al resto, aplicando también awareness (información de presencia). Es un proyecto open source (licencia MIT) y muy fácil de poner en marcha: con apenas unas pocas líneas se lanza un servidor Hocuspocus que escucha conexiones WebSocket y sincroniza los docs Yjs automáticamente ￼.

Hocuspocus agrega funcionalidades útiles out-of-the-box:
	•	Multiplexación: permite manejar múltiples documentos en una sola conexión WebSocket (identificados por un nombre/ID). Esto es eficiente si un usuario tiene varios docs abiertos.
	•	Persistencia con base de datos: mediante extensiones, se puede integrar con bases de datos para cargar/guardar el contenido de los documentos. Por ejemplo, Hocuspocus ofrece un Database Extension donde uno define cómo fetch el contenido inicial de un doc (desde Postgres, Redis, etc.) y cómo store periódicamente o al cerrar ￼ ￼.
	•	Autenticación y autorizaciones: permite configurar un hook onAuthenticate para verificar tokens de cliente al conectarse ￼. Esto es perfecto para integrarlo con Supabase Auth (o cualquier JWT). De hecho, se puede hacer que el cliente envíe su token de Supabase en la conexión, y Hocuspocus validar ese JWT y asociarlo a la conexión (rechazando si no es válido) ￼. A partir de ahí, en otros hooks (p. ej. onLoadDocument) podemos usar los datos del token (usuario, rol) para aplicar lógica de permisos (como dar acceso de solo lectura a algunos usuarios) ￼ ￼.
	•	Awareness (presencia): Hocuspocus integra el mecanismo de Yjs Awareness, que básicamente mantiene un pequeño estado por cliente (ej. {userName: "Ana", cursorPos: {x,y}, color: "#F00"}) y lo difunde a los demás en la sala. Así, los clientes pueden saber quién está conectado y datos de su estado UI. Yjs.awareness es lo que típicamente se usa para implementar los cursores remotos, selecciones, etc., ya que emite eventos cuando alguien actualiza su info de awareness (por ejemplo, al mover su ratón, actualiza su posición en su awareness local y eso se envía a los demás). Es una solución ligera para presencia en tiempo real. Hocuspocus soporta awareness de forma nativa, facilitando construir experiencia Figma (cursores colaborativos, etc.) ￼.

Compatibilidad con React Flow: Yjs es perfectamente compatible con React (se puede usar con state hooks, context, etc.) y con React Flow. Una manera común es almacenar la lista de nodos y edges dentro de un tipo Yjs compartido (por ejemplo un Y.Map o Y.Array). Cada vez que Yjs detecta un cambio, actualizar el diagrama. Inversamente, capturar eventos de React Flow (como onNodesChange) para aplicar modificaciones en el documento Yjs en vez de en el estado local. De esta forma, Yjs actúa como la fuente de la verdad del grafo colaborativo. De hecho, la propia documentación de React Flow recomienda Yjs para colaboración y muestra ejemplos de integración. Existe un ejemplo oficial (React Flow Pro) de un grafo colaborativo usando Yjs ￼ ￼, el cual utiliza Yjs con un proveedor de WebRTC (otra opción P2P en lugar de servidor). También la empresa Synergy Codes (especializada en diagramas) publicó guías demostrando cómo sincronizar React Flow con Yjs ￼ ￼. En resumen, Yjs puede manejar estructuras arbitrariamente anidadas, por lo que representar los nodos/edges (probablemente como arrays de objetos dentro de un map) es viable y soporta updates granulares (mover un nodo sería actualizar sus coordenadas en el Y.Map, lo cual se propaga sin reemplazar todo).

Rendimiento y escalabilidad: Yjs está probado en producción en muchos escenarios. Es muy eficiente aplicando diffs binarios pequeños en cada update, por lo que incluso con muchos usuarios las actualizaciones son manejables en tamaño. Según sus usuarios, escala bien incluso con número ilimitado de usuarios y documentos grandes ￼. Hocuspocus en sí está diseñado para ser escalable: se puede ejecutar en múltiples instancias si se implementa un mecanismo de pub/sub entre servidores (por ejemplo usando Redis) para que los docs abiertos en distintos nodos de servidor intercambien los diffs. Con una arquitectura adecuada, soportar cientos o miles de usuarios distribuidos en docs diferentes no debería ser problema. Un artículo menciona que Hocuspocus “tiene todo para escalar a un millón de usuarios” ￼ (obviamente habrá que dimensionar la infraestructura, pero señalan que la arquitectura asíncrona de Hocuspocus + Yjs lo permite).

Integración con Supabase (auth y DB): Esta combinación encaja muy bien con Supabase:
	•	Auth: Como se comentó, Hocuspocus permite usar los JWT de Supabase para autenticar conexiones. Un enfoque es pasar desde el cliente el access_token (y quizá el refresh_token) en la conexión WebSocket, y en onAuthenticate inicializar un cliente supabase en el servidor para validar ese token contra Supabase (llamando auth.getUser() con ese token) ￼. Esto efectivamente autentica al usuario y nos da su identidad dentro de Hocuspocus ￼. Luego podemos adjuntar el objeto user al contexto de la conexión y usarlo en subsiguientes hooks (por ejemplo para verificar permisos al acceder a cierto documento) ￼ ￼. Un ejemplo práctico: el blog Emergence Engineering muestra en ~100 líneas cómo montar un backend colaborativo con Hocuspocus + Supabase, incluyendo autenticar y chequear en una tabla de roles si el usuario tiene permisos de edición o es solo lectura ￼ ￼. Cuando un usuario con rol de solo lectura se conecta, aprovechan la característica data.connection.readOnly = true de Hocuspocus para que su cliente no pueda enviar actualizaciones ￼.
	•	Base de datos: Podemos usar Supabase (Postgres) para persistir el documento. Una forma sencilla es tener una tabla documents con columnas id (uuid) y data (bytea) donde almacenamos el estado serializado del Yjs doc. Hocuspocus permite, mediante la extensión Database, definir la función fetch (cargar doc) y store (guardar doc) ￼ ￼. Así, cuando se conecta el primer cliente a un doc, el servidor puede cargar el campo data de la BD, convertirlo a Uint8Array y cargarlo en el Y.Doc; y periódicamente (o al último usuario salir, etc.) guardar el estado actualizado en la base. En el ejemplo con Supabase, realizan el fetch desde Postgres y también consultan una tabla de roles para restricciones ￼ ￼. Cabe señalar que Yjs nos da la representación del documento completa o incremental en formato binario, lo que facilita guardarlo en un campo binario. Inclusive Supabase ha experimentado con una extensión CRDT para Postgres que soporta datos Yjs nativamente ￼, pero aun sin eso, guardarlo como blob funciona bien.
	•	Supabase Realtime: Aunque en este stack usaríamos Hocuspocus para la sincronización en tiempo real, es interesante mencionar que existe un proveedor Yjs para Supabase Realtime (y-supabase) que algunos han estado probando ￼. Este utiliza los canales de websocket de Supabase (que normalmente reaccionan a inserciones/updates en la BD o mensajes broadcast) para intercambiar updates de Yjs entre clientes, evitando tener que desplegar Hocuspocus. Sin embargo, está en fases iniciales y no es aún recomendado para producción ￼. Por ahora, la solución más madura sigue siendo correr Hocuspocus por nuestra cuenta.

Presencia y experiencia Figma: Yjs con awareness permite implementar todos los elementos de presencia fácilmente. Cada cliente, tras autenticarse, puede definir en su awareness datos como {userId, name, color, cursorPosition: {x,y}, nodeSelection: nodeId}. Cuando el cliente mueve su ratón o selecciona otro nodo, actualiza su awareness local, y Hocuspocus difunde ese cambio a los demás. Los demás reciben eventos y pueden renderizar, por ejemplo, un cursor con el nombre y color en la posición {x,y} ￼. Del mismo modo, se pueden resaltar los bordes de un nodo si nodeSelection indica que otro usuario lo tiene seleccionado. Estas actualizaciones de awareness son muy eficientes (deltas pequeños) y no se guardan en el documento CRDT en sí, ya que son efímeras (cuando alguien se desconecta, su entry se borra automáticamente). Esto encaja perfecto con la necesidad de cursores en vivo, avatares y etiquetas de “visto por”.

En resumen, Yjs + Hocuspocus cumple con prácticamente todos los requisitos: proporciona fusión automática de cambios sin conflictos, maneja presencia multi-usuario en tiempo real, persiste el estado en Supabase, y se integra con auth para controlar accesos. Todo con librerías open source y un control total de nuestros datos (los documentos quedan en nuestra base Postgres). El costo es que tenemos que mantener un servidor adicional (Hocuspocus) – aunque es bastante ligero – y dedicar algo de desarrollo a la integración. Afortunadamente, la documentación y comunidad de Yjs/Hocuspocus es activa; en la comunidad de Yjs hay muchos ejemplos e incluso empresas (como Synergy Codes) compartiendo best practices para diagramas ￼. Dado que React Flow no incluye colaboración de serie, esta alternativa es considerada de las más sólidas para añadirla.

Ejemplo de uso: Para ilustrar, imaginemos un flujo: un usuario mueve un nodo en su navegador -> la posición actualizada se aplica al Y.Doc local -> Yjs genera un update delta -> Hocuspocus lo envía a los otros -> los otros aplican ese delta a su Y.Doc -> React Flow se entera (vía un hook) y re-renderiza el nodo en la nueva posición. Todo esto ocurre en milisegundos y de forma transparente para el desarrollador, sin tener que programar manualmente mensajes tipo “mover nodo {id} a x,y” ni algoritmos de merge. Así se logra la “magia” Figma de edición simultánea sin conflictos.

Liveblocks

Ejemplo de colaboración en un diagrama de flujo con React Flow y Liveblocks (múltiples usuarios con sus cursores y nombres coloreados interactuando simultáneamente) ￼

Liveblocks￼ es una plataforma de colaboración en tiempo real todo en uno, ofrecida como un servicio hospedado (SaaS). Su objetivo es simplificar al máximo la adición de experiencias multi-usuario en aplicaciones web, proporcionando APIs de alto nivel para estado compartido, presencia y sincronización sin que el desarrollador tenga que construir su propio backend de websockets ni manejar la complejidad de CRDTs directamente. En otras palabras, Liveblocks ofrece “building blocks” para lograr funcionalidades tipo Figma/Google Docs de forma rápida ￼.

Las características principales de Liveblocks son:
	•	Storage compartido (estado sincronizado): Liveblocks provee estructuras de datos colaborativas llamadas Liveblocks Storage. Estas incluyen tipos conflict-free equivalentes a objetos, listas y mapas (llamados LiveObject, LiveList, LiveMap) ￼. El desarrollador define un modelo de estado (por ejemplo, un LiveMap de nodos, donde cada nodo es un LiveObject con propiedades x, y, label, etc.). Los usuarios pueden modificar este estado a través de métodos proporcionados por la librería (similar a manipular un estado React pero especial). Cualquier cambio se sincroniza en tiempo real a todos los clientes en la misma sala y se aplica con resolución de conflictos automática (Liveblocks internamente utiliza algoritmos de fusión, posiblemente basados en CRDT, de hecho ellos mencionan explícitamente “Automatic conflict resolution” ￼). Esto significa que si dos usuarios editan propiedades diferentes simultáneamente, ambos cambios se reflejan; y si llegan cambios conflictivos sobre la misma propiedad, Liveblocks define un criterio determinista para resolverlos (generalmente último escritor gana, aunque mantienen también historial para revertir). El Storage es persistente en la nube de Liveblocks, es decir, mantiene el estado aunque no haya clientes conectados (similar a como lo haría una base de datos) ￼.
	•	Presence (presencia de usuario): Liveblocks incluye una capa de presencia muy sencilla de usar. Cada usuario en una “room” tiene un pequeño estado de presencia (un objeto JSON plano) que puede contener lo que definamos: típicamente coordenadas del cursor, nombre, avatar, etc. La librería ofrece hooks como useMyPresence y useOthers para actualizar tu estado de presencia y recibir la lista de otros usuarios presentes ￼ ￼. Todo el manejo de entrar/salir usuarios, temporización y difusión lo hace Liveblocks automáticamente usando su infraestructura de WebSockets. La Liveblocks Presence System soporta cosas como live cursors, estados personalizados y está estrechamente integrada con su sistema de conflicto (por ejemplo, datos de presencia también se manejan sin conflictos) ￼. Con un par de líneas podemos transmitir la posición del cursor en cada movimiento de ratón, y Liveblocks se encarga de enviar esa posición a los demás en tiempo real. Igualmente, proporciona componentes UI opcionales (paquete @liveblocks/react-ui) con implementaciones listas de cursores remotos y lista de usuarios presentes.
	•	Broadcast (eventos personalizados): Además del storage y presence, Liveblocks ofrece un canal de eventos broadcast por si se quiere enviar mensajes de forma imperativa (similar a un pub/sub). Útil para casos donde no se quiera almacenar un cambio en el estado sino solo notificar algo transitorio (aunque muchos casos se cubren con presence).
	•	Seguridad y auth: La arquitectura de Liveblocks utiliza un modelo de rooms (salas) identificadas por un ID. Para conectarse a una sala, se necesita un token de autenticación válido para esa sala. Liveblocks ofrece dos modos:
	•	Usar una API Key pública en el frontend (más simple, pero cualquier usuario con la key podría unirse a cualquier sala – apto para prototipos).
	•	Usar una Auth Endpoint en tu backend: tu aplicación verifica al usuario (por ej. con Supabase) y hace una solicitud a la API de Liveblocks con tu secret key para generar un token JWT limitado a ese usuario/sala. Este token se envía al cliente, y el cliente entra a la sala con él. Este flujo asegura que solo usuarios válidos puedan entrar a salas autorizadas. Liveblocks soporta también asignar roles/permisos en el token para controlar, por ejemplo, acceso de solo lectura.
	•	Liveblocks tokens por defecto incluyen la identificación del usuario (puedes meter userId, nombre, avatar URL en el token), lo cual el servidor de Liveblocks usará para la presencia. Así, se integra perfectamente con Supabase Auth: podríamos crear una función serverless (Edge Function de Supabase o similar) que reciba la supabase.session del usuario y, si todo bien, devuelva un token firmado de Liveblocks para la sala solicitada.
	•	Infraestructura escalable: Al ser un servicio, Liveblocks corre su propia infraestructura de WebSockets distribuidos (mencionan red global Edge) para baja latencia ￼. Ellos se encargan de reconexiones automáticas, tolerancia a desconexiones breves (tienen buffering de cambios offline: si un usuario pierde conexión unos segundos, puede seguir editando offline y Liveblocks sincroniza al reconectar) ￼, y en general de la orquestación de todos los mensajes en la sala. Desde nuestra perspectiva, es prácticamente magia: no tenemos que manejar servidores ni conexiones, solo usar sus hooks en React.

Integración con React Flow: Liveblocks está pensado para integrarse fácilmente con aplicaciones React. Ofrecen un paquete @liveblocks/react con un  para englobar la parte colaborativa en el árbol de componentes. Podemos emplear sus hooks para vincular el estado de Liveblocks con el de React Flow:
	•	Podríamos mantener los nodos y edges en el Storage de Liveblocks en lugar de en React state. Por ejemplo, una LiveList de nodos y una de edges. Luego usar el hook useStorage para obtener esos datos y pasarlos a React Flow como nodes y edges. Cuando hay cambios (por otros usuarios), el hook hará que React re-renderice con los nuevos datos ￼.
	•	Para manejar las acciones del usuario local (drag, conectar, etc.), se reemplaza las funciones onNodesChange, onEdgesChange de React Flow por unas que en lugar de setState local, apliquen las operaciones en el Liveblocks storage (p. ej. actualizando la propiedad position de un nodo en el LiveObject correspondiente, o removiendo/añadiendo un elemento en la LiveList). Esto se hace de forma mutable con métodos que proporciona Liveblocks (ej: update() en LiveObject, push()/delete() en LiveList).
	•	Liveblocks emitirá esos cambios a todos, incluidos el propio usuario (aunque usualmente ya aplicó el cambio local optimistamente). El resultado es que todos ven la actualización. Conflictos concurrentes: supongamos que dos usuarios arrastran el mismo nodo simultáneamente a lugares distintos. Liveblocks garantiza “automatic conflict handling” ￼; internamente, su CRDT quizá decida por timestamp cuál posición final gana. En la práctica, uno de los movimientos prevalecerá y el otro usuario verá el nodo saltar. Para minimizar esto, se puede usar la presencia para que cuando un usuario está arrastrando un nodo, se indique a otros (ej. un icono) para evitar intencionalmente editar el mismo elemento. A falta de locking explícito, esta señal suele ser suficiente en UI colaborativas.
	•	Cursores remotos y selección: Muy sencillo: con useMyPresence cada cliente envía {cursor: {x,y}, selection: selectedNodeId} y con useOthers los componentes UI reciben arrays de otros usuarios presentes y sus datos. Renderizar los cursores en el canvas de React Flow es tan fácil como, por cada usuario en Others, dibujar un div absolutamente posicionado en su {x,y} (ajustando según la transformación/zoom del canvas) con su avatar. De hecho Liveblocks publica ejemplos y hasta componentes listos para cursores ￼.
	•	Ejemplo existente: Liveblocks tiene en su repositorio oficial un ejemplo de Flowchart colaborativo usando React Flow + Zustand + Liveblocks (publicado como zustand-flowchart example) ￼. Esto demuestra que la integración es factible y relativamente sencilla. En ese ejemplo manejan el estado compartido con Liveblocks (posiciones de nodos, etc.) y usan Zustand para orquestar la sincronización con la instancia React Flow. La existencia de este ejemplo y la documentación asociada es un buen aval de compatibilidad.

Rendimiento con múltiples usuarios: Liveblocks está diseñado para soportar un buen número de usuarios por sala. En su plan Enterprise mencionan “usuarios ilimitados”, lo cual sugiere que no hay un límite técnico fijo impuesto (más allá de los recursos). Han indicado que su backend es capaz de escalas altas y que utilizan protocolos eficientes. Los mensajes viajan por websockets centralizados, así que en teoría en una sala con 100 usuarios, cada cambio lo difunde el servidor a 99 clientes. Esto es similar a cualquier servidor websockets. Dado que Liveblocks sí usa estructuras CRDT bajo el capó, los mensajes son deltas compactos (no envía el documento completo salvo en la inicialización). Además, su calidad de servicio es uno de sus puntos de venta, comparándose favorablemente con soluciones genéricas de pub/sub en fiabilidad ￼. Para el caso de un diagrama, es probable que se maneje bien con docenas de usuarios concurrentes sin problema.

Persistencia y recuperación de sesiones: Aquí Liveblocks brilla porque su Storage es persistente automáticamente. Cuando la última persona sale de una room, los datos permanecen en Liveblocks Cloud (durante cierto tiempo, posiblemente indefinido hasta que explícitamente se borre la sala). Cuando alguien vuelve a entrar a esa room, Liveblocks le envía el estado almacenado como estado inicial (esto lo maneja RoomProvider internamente; de hecho su API initialStorage permite definir datos iniciales solo la primera vez que se crea la room ￼). Por lo tanto, no hay que preocuparse de implementar guardados manuales – la plataforma se encarga. Eso sí, estos datos residen en la nube de Liveblocks, no en nuestra base Supabase. Si es necesario tener una copia en Supabase (por requisitos de auditoría u offline), habría que exportarlos manualmente. Liveblocks provee webhooks que pueden notificar eventos (por ejemplo, cuando una room queda vacía podríamos recibir un webhook y decidir guardar el estado en Supabase) o se podría hacer que periódicamente un cliente con permisos mande una snapshot a Supabase. No obstante, para la mayoría de casos se puede confiar en su almacenamiento. Señalar también que Liveblocks tiene una funcionalidad de historial (no detallada en la pregunta, pero existe un concepto de “History” con funciones undo/redo globales si se habilita).

Supabase y Liveblocks juntos: Como ya se mencionó, la integración típica es usar Supabase para nuestro propio backend de usuarios y base de datos de aplicación, y Liveblocks únicamente para la parte colaborativa en tiempo real. Por ejemplo, supongamos que tenemos en Supabase una tabla documents con metadatos de cada diagrama (nombre, owner, etc.). Podríamos almacenar también el ID de Liveblocks room asociada. Los usuarios se autentican con Supabase; al abrir un documento, nuestra app verifica que tienen acceso y luego crea (o reutiliza) un Liveblocks room token para ellos. Ese token se genera en un end-point seguro nuestro (que podría correr en Supabase Edge Functions, Vercel serverless, etc.) usando la secret key privada de Liveblocks. Con la librería @liveblocks/node se puede generar ese token fácilmente pasando user info y room ID ￼. Una vez obtenido, el cliente entra a la sala. Todo este flujo está documentado por Liveblocks y es relativamente fácil si ya contamos con Supabase Auth.

Documentación y comunidad: Liveblocks, al ser un producto comercial para desarrolladores, tiene documentación muy cuidada, ejemplos, SDKs para varias libs (React, Next.js, incluso Vue y Svelte), y soporte (especialmente para clientes de pago). La comunidad no es tan grande como la de Yjs (ya que Liveblocks es más nuevo y cerrado), pero hay bastante contenido: blogs, videos, etc., mostrando integraciones comunes. En cuanto a soporte a largo plazo, Liveblocks es una startup con financiamiento, lo cual suele garantizar mejoras continuas pero implica que dependemos de ellos y de su estabilidad financiera en el futuro.

Ventajas y desventajas resumidas de Liveblocks:
	•	Pros: Integración extremadamente sencilla en frontend (hooks reactivos), cubre presencia, storage y conflicto todo en uno ￼ ￼, ahorra el desarrollo de backend colaborativo (sin servidores propios), optimizado para múltiples casos (whiteboards, docs, etc.), con funcionalidades adicionales (ej. comentarios en contexto, aunque son extras fuera del alcance aquí). Maneja internamente reconexiones, offline edits, etc., brindando una experiencia robusta al usuario final.
	•	Contras: Es un servicio de tercero – implica confiar en Liveblocks para la seguridad de los datos en tránsito y almacenados (aunque ofrecen cifrado y opciones enterprise) ￼. También conlleva costo: tiene un plan gratuito limitado (200 usuarios activos al mes) y planes de pago a partir de $99/mes por 2,500 MAU ￼. Si nuestra aplicación escala mucho en usuarios, esto se vuelve un gasto recurrente significativo. Otro aspecto es la dependencia tecnológica: estamos atados a su SDK; si un día quisiéramos migrar fuera, habría que reimplementar buena parte. Por último, la persistencia de datos fuera de Supabase puede ser inconveniente si deseamos todo centralizado; habría que sincronizar manualmente si es necesario.

Aun con esas consideraciones, Liveblocks es una alternativa muy atractiva cuando se quiere velocidad de implementación y fiabilidad sin adentrarse en CRDTs uno mismo. Para un MVP o incluso un producto final con presupuesto, permite lograr colaboración estilo Figma en tiempo récord. De hecho, ellos mismos promocionan casos de uso como “crear una herramienta de diseño colaborativa tipo Figma” que sus clientes han implementado con su SDK ￼.

En el contexto de React Flow + Supabase, Liveblocks encajaría bien manejando la colaboración, mientras Supabase sigue usándose para persistir la estructura base de los documentos y autenticar usuarios. Sólo hay que diseñar la integración de tokens y quizás una sync final si se quiere guardar el resultado final en Supabase (aunque se podría también consultar el estado a través de la API de Liveblocks al cerrar un documento, ya que tienen endpoints REST).

Automerge + PartyKit

Automerge es otra librería CRDT popular y pionera en el espacio de local-first software. Su API expone un modelo muy sencillo: básicamente se trabaja con un objeto JavaScript (como un JSON) que múltiples usuarios modifican concurrentemente, y Automerge se encarga de fusionar esas modificaciones produciendo un resultado consistente. A diferencia de Yjs, Automerge prioriza la simplicidad de uso y algunas características como mantener todo el historial de cambios (lo que facilita deshacer/rehacer e incluso replicar cambios pasados). Es un proyecto iniciado por Martin Kleppmann (académico notable en sistemas distribuidos) y escrito ahora en Rust (con binarios WASM para usar en web). Automerge v2 ha mejorado mucho en performance respecto a v1, pero aún se reconoce que consume más memoria y CPU que Yjs en documentos de gran tamaño, ya que “Automerge almacena todo el historial del documento, incluyendo elementos borrados, con los costos que ello conlleva” ￼. Por ejemplo, pruebas mencionan que cargar un documento de texto muy grande puede tomar segundos en Automerge versus milisegundos en Yjs ￼. No obstante, para tamaños moderados y estructuras tipo grafo (no texto extenso), Automerge suele rendir suficientemente bien, y sus desarrolladores trabajan continuamente en optimizaciones.

Automerge no impone un transporte; los desarrolladores deben intercambiar deltas o estados entre peers. Esto nos lleva a la combinación con PartyKit.

PartyKit es una plataforma emergente (ahora parte de Cloudflare) que facilita la creación y despliegue de backends en tiempo real (WebSocket orquestation) sin tener que manejar servidores explícitamente. Conceptualmente, PartyKit permite escribir una clase de servidor (en JS/TS) que define cómo manejar conexiones, mensajes, almacenamiento, etc., y luego lo despliega en la infraestructura edge de Cloudflare. Internamente, PartyKit utiliza Cloudflare Durable Objects: cada “Party” (sala) es esencialmente un proceso aislado en la red de Cloudflare que puede mantener estado en memoria y en almacenamiento persistente, y con el cual los clientes se conectan vía WebSocket. Esto es genial porque nos da un ámbito de consistencia por sala (todos los mensajes de esa sala van al mismo objeto, en secuencia) y además escalabilidad global (Cloudflare tiene data centers en todo el mundo, los objetos se ubican cerca de los usuarios y pueden migrar).

Lo interesante es que PartyKit se diseñó para trabajar bien con CRDTs existentes. De hecho, ellos mencionan que “funciona bien con Y.js, Automerge, Replicache, etc., simplemente funcionan” ￼. ¿Qué significa esto? Que podemos, por ejemplo, instanciar un documento Automerge dentro de un PartyKit and and en cada evento de cliente, fusionar cambios, etc., de manera sencilla.

En la práctica, usar Automerge + PartyKit implicaría:
	•	En el lado servidor (PartyKit): Crear una clase (p. ej. FlowServer) que extienda la lógica PartyKit. Al inicializar, crear un Automerge.Doc que represente el estado del diagrama (nodos, edges, etc.). PartyKit nos permite sobreescribir métodos como onConnect, onMessage, onDisconnect.
	•	Cuando un cliente se conecta, podríamos enviarle el estado actual del documento (Automerge permite serializar el documento o, mejor, calcular un sync message diferencial para ese cliente nuevo).
	•	Cuando un cliente envía un mensaje (por ej. una operación de actualización), el onMessage del servidor recibiría esos datos. Aquí podríamos aplicar esa operación al Automerge.Doc servidor (p. ej. utilizando Automerge.merge o aplicando un cambio concreto si enviamos formato patch). Alternativamente, podríamos usar Automerge en modo peer-to-peer donde los clientes envían cambios y el servidor solo reenvía – pero más robusto es tratar el servidor como autoridad que realiza el merge.
	•	Después de actualizar el documento en el servidor, este generaría patches para difundir a todos los demás clientes (usando Automerge.getChanges o similar) y enviaría vía WebSocket esos cambios. Los clientes al recibirlos los aplican a sus propios Automerge.Doc.
	•	En el lado cliente: Cada cliente también tendría una instancia Automerge de la estructura del grafo. Podría iniciar vacía o con un estado inicial provisto al conectar. Cuando el usuario hace un cambio (e.g. mueve un nodo), en vez de aplicarlo directamente a React Flow, primero aplica un cambio a su doc Automerge local (Automerge usa una sintaxis de change function donde mutas un draft del estado). Esto produce un delta que se envía al servidor PartyKit via WebSocket.
	•	Mientras tanto, puede optimistamente reflejarlo en la UI (ya que tiene el doc local actualizado).
	•	Cuando recibe del servidor los merges, aplicará esos merges (que pueden incluir su propio cambio – redundante – y cambios de otros). Automerge garantiza que aplicar su propio cambio de nuevo no duplica nada y simplemente lo ignora al ver que ya está integrado.
	•	React Flow se alimenta de la versión actual del Automerge doc (quizá a través de un estado derivado o un adapter).
	•	Presencia: PartyKit no tiene un sistema de presencia pre-hecho, pero es trivial añadirlo. Por ejemplo, en onConnect podríamos guardar en una lista el userId y quizás metadata (nombre, color) de cada conexión. PartyKit nos permite usar su almacenamiento transitorio o persistente para trackear esto. Luego podríamos implementar un ping de cursor: cada vez que un cliente mueva su ratón, envía un mensaje "cursor": {x,y} al servidor, y este hace un broadcast de ese mensaje a todos los demás (o mantiene un estado global de cursores y lo envía cuando alguien se conecta). Igualmente para selecciones. Es básicamente manual, pero con la flexibilidad total – podemos decidir no guardar presencia en Automerge (para no ensuciar el doc con datos efímeros) sino manejarla paralelamente vía broadcast.
	•	Cabe destacar que, dado que PartyKit nos deja ejecutar JS en el servidor, podríamos incluso implementar un Awareness similar al de Yjs ourselves, or simply forward messages. También podríamos take advantage del PartyKit Connection Metadata: PartyKit tiene identificadores únicos para cada conexión y posibilidad de asociar metadata.
	•	Persistencia: Cloudflare Durable Objects tienen almacenamiento persistente (un KV por objeto) que se puede usar para guardar datos entre instancias. PartyKit facilita esto: ofrece métodos para leer/escribir en el storage persistente ￼. Podríamos serializar el estado Automerge (que en v2 tiene un formato binario compacto de backend) y guardarlo periódicamente o al apagar. Incluso sin hacerlo manualmente, Cloudflare mantendrá en memoria el DO mientras haya cierta actividad y luego lo puede hibernar guardando su memoria. Aun así, conviene implementar persistencia explícita:
	•	Opción 1: Guardar en DO Storage. Cuando no queden usuarios o cada X segundos, hacer this.party.storage.put("doc", automerge.save(doc)). Y en onConnect si doc no existe en memoria (p.ej la primera conexión tras hibernar), intentar cargar de storage. Esto mantendría el estado entre sesiones. La free tier de PartyKit borra storage cada 24h ￼, pero en modo desplegado en tu propia cuenta Cloudflare, los DO storage son durables hasta que uno los borre.
	•	Opción 2: Integrar con Supabase: Al igual que con Hocuspocus, podríamos llamar desde el DO a Supabase (por REST HTTP o supabase-js si lo soporta) para guardar el estado en Postgres. Sin embargo, llamar APIs externas desde DO agrega latencia y dependencia, quizás es más sencillo confiar en el storage interno para persistencia de corto plazo, y quizá de vez en cuando enviar una snapshot a Supabase de respaldo.

Integración con React Flow: Similar a Yjs, necesitamos conectar Automerge con React Flow. No existe una integración oficial prehecha, pero la idea sería:
	•	Representar los nodos/edges en la estructura Automerge (por ejemplo, un objeto con propiedades nodes (mapa de id->nodo) y edges). Automerge permite colecciones de objetos, etc.
	•	Cada cliente, al aplicar cambios de Automerge, actualiza el estado de React Flow. Podemos usar un estado derivado (ej: un estado React que se derive del Automerge doc) o incluso usar Automerge como fuente directa dentro de a custom React hook (pero Automerge no es reactive por sí mismo). Una estrategia es suscribirse a cambios de Automerge – se puede instrumentar manualmente o usar un wrapper.
	•	Existen algunos proyectos que integran Automerge con React state (p.ej. usando Proxy or hooking into useEffect on changes).
	•	En PartyKit, habrá latencia mínimamente mayor que en Hocuspocus, ya que cada cambio pasa por la red hasta Cloudflare DO y regresa; pero es similar a un servidor central normal. Cloudflare edge puede reducir latencia si hay un data center cercano a usuarios.

Ventajas de Automerge+PartyKit:
	•	Todo es open source o controlable (PartyKit es open core y permite desplegar en tu propia cuenta Cloudflare, lo cual es esencialmente autoservicio). No dependemos de un SaaS de terceros con costo por usuario (PartyKit actualmente es gratis en Cloudflare dev mode; en tu propia cuenta pagas solo uso de Cloudflare Workers que suele ser barato).
	•	Flexibilidad: Podemos personalizar la lógica del servidor a gusto. Por ejemplo, podríamos implementar lógica de negocio en el DO (validaciones, comandos especiales, integraciones con otros servicios) que sería más complicado en Hocuspocus sin modificar su código. PartyKit es básicamente un pequeño servidor Node per room, con la libertad de usar cualquier paquete NPM, incluyendo cosas como integraciones con Supabase, IA, etc., directamente en la edge.
	•	Edge performance: Los DO de Cloudflare suelen ubicarse cercanos geográficamente. Para usuarios globales, esto puede reducir la latencia en comparación con tener un solo servidor en X región. PartyKit se encarga de rutear inteligentemente conexiones de usuarios a la instancia correcta de DO ￼. También puede escalar en el sentido de que distintas salas viven en distintos DO en paralelo.
	•	Automerge en sí tiene algunas ventajas conceptuales: al mantener historia, uno podría habilitar funcionalidad de Time Travel o auditoría (saber quién hizo qué cambio mirando los diffs históricos), aunque eso aumente el tamaño. Y al ser JSON-like, es cómodo de entender.

Desventajas de esta opción:
	•	Mayor esfuerzo de implementación: A diferencia de Yjs+Hocuspocus o Liveblocks que ya dan muchos componentes hechos, aquí tendremos que desarrollar manualmente la lógica de sincronización de Automerge en PartyKit, así como la capa de presencia. PartyKit facilita la infraestructura pero no nos da la sincronización CRDT lista (aunque es relativamente sencillo aplicar Automerge.merge).
	•	Menos madurez en ejemplos: PartyKit es muy nuevo (apareció en 2023) y aunque hay ejemplos (chat, cursors, incluso un Multiplayer text editor de ejemplo que probablemente usa Automerge o Yjs ￼), la comunidad es aún pequeña. Automerge ha existido años, pero su uso en escenarios de producción grandes ha sido limitado en comparación con Yjs. Esto significa potencialmente más incertidumbre o debugging.
	•	Performance incognita: Si bien PartyKit dice soportar “tens to thousands of users” por DO ￼, un solo DO corre en un solo core Node.js. No sabemos con exactitud cómo rendiría con, digamos, 100 usuarios haciendo muchas ediciones concurrentes en Automerge. Seguramente puede con 10-20 usuarios sin problema. Cloudflare asegura un buen rendimiento de sus DO, pero habría que vigilar el throughput. Automerge, con su overhead, podría saturar la CPU del DO antes que Yjs lo haría en caso de cambios masivos.
	•	Herramientas de debug limitadas: Con Liveblocks tienes su dashboard, con Hocuspocus tienes logs en tu server, con PartyKit/Cloudflare tienes también logs y un inspector DO, pero la experiencia de debug puede ser un poco más compleja (entorno distribuido).
	•	Supabase integration: se puede lograr como dijimos (verificar JWT en PartyKit). PartyKit proporciona guía de autenticación, donde puedes rechazar conexiones no autorizadas fácilmente ￼. Sin embargo, aquí tienes que obtener/validar el JWT en un Worker Cloudflare – significa cargar la supabase-js o hacer una llamada al endpoint de Supabase para validar token. Alternativamente, emitir tu propio JWT para PartyKit en tu backend al igual que con Liveblocks. Podríamos, por ejemplo, utilizar Supabase Functions para generar un token firmado con una secret compartida que PartyKit entienda. Dado que PartyKit está en tu control, incluso se podría usar el mismo Supabase JWT y en PartyKit verificar su firma si se incluyen la clave pública de Supabase. Todo es posible pero nada es plug-and-play.
	•	Persistencia duplicada: si guardamos en DO storage y también en Supabase, habría que diseñar cómo mantenerlos en sync. A lo mejor decidimos Supabase solo como respaldo periódico y confiar en DO para la sesión activa.

En general, Automerge+PartyKit ofrece un camino “hazlo tú mismo” pero con un excelente soporte en infraestructura. Nos permite evitar montar un servidor propio (aprovechamos Cloudflare) y mantener la filosofía open source. Podría ser recomendable para un equipo que quiera máxima flexibilidad y tenga conocimientos en CRDTs y backend realtime. Si bien para el caso de uso dado Yjs con Hocuspocus ya proporciona casi todo hecho, PartyKit tiene la ventaja de integrar nativamente en la edge (lo que puede dar menos latencia global) y, de hecho, también puede usarse con Yjs. Es importante destacar esto: PartyKit lanzó un módulo llamado Y-PartyKit para correr un servidor Yjs dentro de DO sin esfuerzo ￼ ￼. Así que podríamos optar por Yjs sobre PartyKit en vez de Hocuspocus sobre un VM tradicional. Esto no estaba en la lista original de alternativas, pero es otra mezcla posible (CRDT Yjs + PartyKit). De todos modos, hablando de Automerge en particular, PartyKit es probablemente la forma más moderna de usarlo en colaboración hoy (alternativas serían usar algo como WebRTC P2P which doesn’t scale well, or writing a Node server from scratch, which PartyKit essentially abstracts).

En producción, ¿quién usa esto? PartyKit ya mencionó algunos usuarios: la librería de whiteboard tldraw￼ migró su backend colaborativo a PartyKit (antes usaban y-websocket). BlockNote (editor tipo Notion) también usa PartyKit ￼. Estas aplicaciones manejan datos similares (diagramas, texto) con CRDT. En cuanto a Automerge, aplicaciones como el bloc de notas “Muse” en iPad lo utilizan para sincronización P2P offline (aunque no necesariamente multiusuario en vivo de más de 2). La adopción va en aumento a medida que Automerge 2.0 mejora rendimiento. Martin Kleppmann y equipo han fundado una empresa (Automerge Inc) que podría lanzar servicios, pero por ahora es solo la lib.

Resumiendo Automerge + PartyKit:
	•	Compatibilidad con React Flow: Buena, pero integración manual. Representar el grafo en Automerge es factible y la sincronización la controlamos nosotros.
	•	Documentación/comunidad: PartyKit docs claras, ejemplos; Automerge docs suficientemente buenas (y un libro “Local-first Coop” en camino). Comunidad más pequeña que Yjs, pero entusiasta.
	•	Rendimiento: Adecuado para cantidades moderadas de datos y usuarios, pero con riesgo de ser más lenta que Yjs en casos extremos ￼. PartyKit escala bien a nivel infraestructura.
	•	Persistencia: Posible vía Durable Objects o manual a Supabase. No automática out-of-box, debemos implementarla (pero es flexible).
	•	Supabase integración: Posible en auth (verificar JWT en DO) y en almacenamiento (guardar snapshot en Supabase). Hay que codificarlo pero hay ejemplos similares en comunidad (por ejemplo, usar DO para otros casos con Supabase).
	•	Ejemplo cercano: No tenemos uno público exacto de Automerge+ReactFlow, pero sí de Automerge + PartyKit para texto y ReactFlow + PartyKit (por separado). Combinarlo es trabajo de ingeniería, no investigación teórica (o sea, realizable con esfuerzo razonable).

Otras alternativas modernas para presencia y CRDTs

Además de las tres opciones principales anteriores, vale la pena mencionar brevemente otras soluciones o componentes que podrían considerarse para lograr colaboración en tiempo real:
	•	Supabase Realtime (canales y presencia): Supabase incluye un componente de Realtime basado en Phoenix. Inicialmente estaba centrado en enviar cambios de la base de datos a clientes, pero en versiones recientes añadieron canales genéricos y presencia (similar a Phoenix Presence). Esto significa que uno puede crear un canal, unirse con un usuario (con seguimiento de quién está conectado) y transmitir mensajes de forma pub/sub a todos en el canal. De hecho, Supabase Realtime implementa presencia sobre un CRDT delta-state internally para trackear usuarios ￼. En teoría, podríamos usar solo Supabase (sin Yjs) para la colaboración: los clientes envían mensajes tipo “añadir nodo X” o “mover nodo Y a (x,y)” a un canal; todos los demás reciben esos mensajes y los aplican localmente. También podríamos aprovechar la base de datos: cada cambio se escribe en una tabla (p. ej. updates) y el servidor supabase lo transmite vía Realtime. Sin embargo, esto nos deja con el problema de fusionar simultáneos: Supabase no resolvería conflictos, simplemente aplicaríamos los mensajes en orden de llegada (lo cual suele equivaler a last write wins arbitrario). Podríamos implementar cierta lógica de versiones pero básicamente reinventaríamos un OT/CRDT manualmente – no muy recomendable. Supabase Realtime por sí solo es excelente para presencia básica y eventos, pero para estados complejos concurrentes es mejor apoyarse en una capa CRDT. De hecho, los desarrolladores de Supabase han explorado integrar Yjs: existe el proyecto experimental pg_crdt para Postgres que permitía almacenar un documento Yjs o Automerge en una tabla y usar Supabase Realtime para difundir los cambios ￼. A futuro, podríamos ver a Supabase dando soporte más directo a colaborativo (han mostrado interés), pero hoy por hoy tocaría mucho trabajo manual. En conclusión, es posible usar Supabase para presencia (por ejemplo, en lugar de Yjs Awareness podríamos usar supabase.channel('room').track({cursor:..}) y on('presence') para recibir updates), combinado con un CRDT en capa de app (y-supabase lo intenta) ￼. Pero esta ruta es menos probada y su soporte es limitado, salvo para casos muy simples o prototipos.
	•	Loro: Es una librería CRDT más reciente (iniciada en 2023) que busca mejorar algunos aspectos de Yjs/Automerge. Loro está escrita en TypeScript y WASM, y presume de alta performance (optimizaciones de memoria, CPU) y tipos CRDT avanzados para texto, listas ordenables (MovableList), árboles jerárquicos (MovableTree) y mapas LWW ￼ ￼. Ofrece una API fácil para convertir objetos JSON en tipos colaborativos y mantiene además un historial de versiones integrado (permite hacer time-travel tipo Git en el estado) ￼ ￼. Loro podría ser considerada una alternativa a Yjs o Automerge como capa CRDT. De hecho, en su página mencionan explícitamente casos de canvas de diseño estilo Figma con movimientos, deshacer/rehacer y sync en tiempo real ￼ – exactamente nuestro caso de uso. La desventaja es que Loro aún es joven; aunque algunas startups la usan, la comunidad es pequeña comparada con Yjs. Además, Loro no provee un servidor listo: tendríamos que emparejarla con un transporte (posiblemente PartyKit funcionaría aquí también, dado que soporta libs arbitrarias). Hasta ahora Loro no tiene integración conocida con React Flow, pero en teoría se usaría de forma similar a Yjs. Si buscamos lo más bleeding-edge, Loro es interesante, pero asumiría más riesgo y encontrar ayuda podría ser más difícil.
	•	Microsoft Fluid Framework: Es un marco de colaboración de Microsoft, open source, que utiliza CRDTs bajo el concepto de DDS (Distributed Data Structures). Permite definir objetos compartidos (mapas, secuencias, etc.) y provee un cliente que sincroniza mediante un servicio (Azure Fluid Relay o un servidor local llamado Tinylicious). Fluid es potente y fue usado en Office Live y productos de MS, pero su complejidad es alta. Integrarlo con React Flow sería posible (similar a Liveblocks, tiene un container de estado y se actualizaría React Flow), pero la barrera de entrada es mayor. Además, requiere alojar un servicio Fluid (no trivial de escalar por cuenta propia; por eso ofrecen Azure). Dado que hay soluciones más ligeras y focalizadas (Yjs), Fluid quizás sea “demasiado” para este proyecto. Solo lo mencionaríamos si ya se usara tecnología Microsoft o se quisiera experimentar con su modelo. La tendencia en la comunidad React está más con Yjs/Automerge por simplicidad.
	•	Convergence: Convergence (convergencelabs) es una plataforma completa de colaboración en tiempo real que apareció hace unos años. Ofrece un servidor que soporta distintos modelos de dato (OT para texto, JSON shareable, etc.), con presencia, roles, etc., y un cliente JS. Aunque interesante, no ganó tanta tracción y su modelo es más cerrado comparado a usar CRDT libs libres. Podría hacer lo que queremos, pero implica aprender su API propietaria y desplegar su servidor. Dado que no se menciona frecuentemente en 2025 en nuevos proyectos, es probablemente preferible usar las opciones ya discutidas.
	•	Logux: Es una librería de sincronización de estado de Evil Martians. Se basa en una cola de log de acciones (similar a Redux) que se replican en cliente-servidor. Cada cambio es una acción registrada con timestamp/ID y se sincroniza. Logux garantiza entrega confiable y tiene algunas capacidades de resolución (por ejemplo, acciones que se anulan mutuamente), pero no es un CRDT per se. Para un grafo colaborativo, se podría usar, pero habría que definir cuidadosamente cómo se fusionan acciones concurrentes. Podría degenerar también en last write wins si no se hace nada especial. Su principal atractivo es para sincronizar estados Redux offline-first. En nuestro contexto, podríamos modelar movimientos de nodos como acciones Redux y Logux replicaría. Sin embargo, resolver dos acciones conflictivas (mover el mismo nodo) quedaría de nuestra parte (tal vez la última recibida se aplica). Logux es interesante pero menos orientado al multiedición simultánea de un mismo ítem que un CRDT. Por eso, aunque es “moderno”, no lo pondría por encima de Yjs o Automerge para este caso.
	•	TinyBase: Es una biblioteca de base de datos local reactiva para front-end. Tiene una arquitectura de tablas, celdas y queries en memoria, y puede sincronizarse remotamente con lógica personalizada. TinyBase en sí no ofrece multi-usuario, pero se menciona porque combinada con PartyKit se puede lograr (hay un starter kit PartyKit + TinyBase) ￼. Básicamente, TinyBase podría servir de capa de modelo en el cliente (almacenando nodos y edges) y PartyKit se encargaría de replicar operaciones entre clientes, aplicando reglas para merges. Aun así, sería como crear un CRDT desde cero, usando TinyBase para detectar cambios y PartyKit para aplicarlos remotamente. No aporta beneficio claro frente a usar Yjs/Automerge directamente.
	•	Otras bibliotecas locales: Existe un abanico de proyectos nacientes en el mundo CRDT: por ejemplo Replica (antes SyncedStore) que es un wrapper sobre Yjs para facilitar estados tipo Zustand; Milk (CRDT by  danxh) para estado React; incluso soluciones de database sync como ElectricSQL (CR-SQLite) que permiten sincronizar una base SQLite local con Postgres vía CRDTs. Electric podría, en teoría, sincronizar una tabla de nodos y edges entre múltiples clientes, confluyendo en Postgres. De hecho Electric utiliza el algoritmo de crdt de fila en SQLite. Sin embargo, esto está más pensado para colab asíncrona u offline (ex: dos usuarios editan bases de datos locales y se mezclan sus cambios). Para un canvas tiempo real, no es la solución más directa, porque implicaría latencias mayores (cada cambio viaja a servidor DB y de ahí a otros) y carece de presencia/cursor, etc. Aún así, Electric es una “alternativa moderna” para sincronización multi-master que merece mención ￼, solo que no encaja tanto con la parte de presencia en vivo.

En definitiva, las opciones líderes hoy para lograr un Figma-like en nuestro stack se alinean con lo analizado: o bien usamos Yjs (u otra lib CRDT) con nuestra infraestructura (sea Hocuspocus, PartyKit u otro), o usamos un servicio especializado como Liveblocks. Las demás alternativas o son complementarias (Supabase Realtime como transporte), o están en fases tempranas (Loro), o son específicas de nicho.

Para una comparación más directa, a continuación resumimos las tres opciones principales (Yjs+Hocuspocus, Liveblocks, Automerge+PartyKit) en función de varios criterios:

Comparativa de las alternativas principales

Criterio	Yjs + Hocuspocus	Liveblocks	Automerge + PartyKit
Arquitectura	Librería CRDT (Yjs) + servidor WebSocket propio (Hocuspocus). Código abierto completo; despliegue autogestionado.	SDK frontend + backend SaaS (nube de Liveblocks). Servicio cerrado (client libs open source); no gestionas servidores.	Librería CRDT (Automerge) + backend personalizado en PartyKit (Cloudflare DO). Código abierto (tu logic + PartyKit); infraestructura serverless autoescalable.
Resolución de conflictos	CRDT optimizado: merges automáticos sin conflictos de nodos, posiciones, etc. Yjs está probado en producción, alta perf incluso con docs grandes ￼.	CRDT interno en Storage: merges automáticos también. Maneja datos tipo JSON (LiveObject/List) con conflictos resueltos automáticamente ￼. Similar eficacia, aunque detalles internos no públicos.	CRDT Automerge: merges automáticos, pero performance algo menor en casos extremos ￼. Historial completo (permite undo global) a costo de más memoria. Se puede necesitar snapshots para limitar crecimiento.
Presencia (cursors, etc.)	Yjs Awareness API incluida; Hocuspocus la soporta nativamente ￼. Fácil de mandar cursors, selecciones, etc., y recibirlas en todos los clientes ￼. Debes implementar la UI en React Flow, pero los datos los tienes.	Parte central del producto: hooks usePresence y useOthers facilísimos ￼ ￼. Liveblocks trae ejemplos de cursors, avatar stack, etc. Prácticamente plug-and-play para ver usuarios y sus acciones ￼.	PartyKit no trae presencia predefinida, debes programarla. Puedes implementar un canal para cursors (broadcast) o incluso usar Automerge para un map de presencia. Tienes flexibilidad total pero todo manual. PartyKit ofrece ejemplos (p.ej. cursors with flags demo) para guiarte ￼.
Persistencia del estado	Via Hocuspocus DB extension puedes guardar el doc Yjs en Supabase (Postgres). Yjs snapshot es binario compact. Recuperación al reconectar mediante fetch de BD ￼ ￼. Tú controlas cuándo guardar (onChange, intervalos, etc.). Integración directa con tu base de datos.	Automática en la nube Liveblocks: el contenido de la sala persiste en sus servidores cuando no hay clientes ￼. Al reingresar, obtienes el último estado. No tienes que hacer nada, pero los datos viven fuera de Supabase (posible guardarlos manualmente vía webhooks o API si requieres backup propio).	Puedes usar el Durable Object Storage de Cloudflare para persistir el doc Automerge. Debes implementar guardado/carga (p.ej. this.party.storage.put). PartyKit DO puede hibernar y revivir con estado intacto, pero free tier lo limpia cada 24h ￼. Alternativamente, llamar a Supabase REST para guardar snapshot en Postgres. Persistencia es bajo tu control.
Integración Supabase Auth	Muy buena: puedes exigir token JWT Supabase en la conexión WS y verificarlo con supabase-js en onAuthenticate ￼. Ejemplo disponible que combina roles/permisos de Supabase con Hocuspocus ￼ ￼. Aprovecha RLS de Supabase para control fino.	Vía endpoint de auth: debes crear un servicio (puede ser una Function en Supabase) que valide usuario Supabase y genere token Liveblocks con el user ID/alias. Liveblocks facilita SDK para firmar tokens ￼. Paso extra pero bien soportado. Supabase puede seguir guardando metadatos/rows pero no el estado en tiempo real.	Puedes validar JWT Supabase en PartyKit (por ejemplo usando librería jsonwebtoken con la secret de Supabase). PartyKit docs explican hook de auth para rechazar conexiones no autorizadas ￼. Tienes que obtener la secret or jwks de Supabase en tu DO env. Es un poco DIY pero factible. También podrías emitir tokens propios. En cuanto a permisos, al tener user info, puedes codificar lógica dentro del DO (ej. ignorar cambios de usuarios no autorizados a ciertos docs).
Compatibilidad React/Flow	Yjs es independiente de UI, pero existen patrones probados para React. React Flow + Yjs se ha implementado en ejemplos ￼ y por terceros ￼. Necesitarás conectar eventos de React Flow al doc Yjs y viceversa (posible con hooks/effects). Herramientas como valtio-yjs o syncedStore pueden ayudar a vincular Yjs con estado React.	Excelencia en integración React: provee Hooks que encajan con el ciclo de vida de componentes. Puedes mantener state colaborativo sin preocuparte de suscripción manual – useStorage te da reactividad ￼. En React Flow, se integra vía estado externo (Zustand, context). Liveblocks incluso tiene un ejemplo específico con React Flow ￼, lo que valida la compatibilidad.	Debes implementar la capa de sincronización con React. Automerge puede integrarse pero no trae su propio mecanismo reactivo; seguramente usarías useEffect para aplicar cambios y forzar re-render. Alternativamente, podrías utilizar alguna lib auxiliar (por ej. automerge-repo con React bindings, aunque está en desarrollo). PartyKit proporciona el canal de comunicación, pero tú suscribes el cliente a mensajes y actualizas state. Con más código se logra, pero no es tan inmediato.
Escalabilidad (usuarios)	Muy alta. Yjs soporta muchos usuarios y operaciones – su algoritmo incremental escala sublinealmente en muchos casos. Hocuspocus puede escalar horizontalmente con pub/sub. Se tiene casos de uso reales con docenas de editores simultáneos sin problema. Un solo servidor puede manejar cientos de conexiones (según recursos). La limitante suele ser la carga del propio documento (Yjs mantiene estructura compacta en memoria).	Alta. Liveblocks afirma soportar muchos usuarios; su backend está construido sobre infra escalable y redes edge. Tienen planes enterprise para necesidades mayores (podría implicar instancias dedicadas). Para <100 usuarios colaborando concurrentemente, debería funcionar fluido según testimonios. De hecho, su presencia delta-based es eficiente. Eso sí, en free plan limitan 200 MAU (no concurrentes, sino al mes), pero técnicamente no hay un “hard limit” concurrencia salvo quizás ancho de banda.	Escalable en distribución geográfica: cada doc (Party) aislado, se pueden tener miles de docs activos. Cada DO puede manejar, según Cloudflare, hasta ~1000 conexiones simultáneas de forma estable. Pero la performance de Automerge en un DO con 1000 clientes enviando cambios puede ser un cuello de botella. Posiblemente es razonable esperar decenas de usuarios con buena experiencia, pero habría que probar si cientos saturan. PartyKit en sí soporta escalas grandes (ej: eventos con miles de usuarios para encuestas en vivo han sido construidos con PartyKit).
Comunidad y soporte	Yjs tiene una comunidad amplia y madura: foro discuss.yjs.dev, muchas integraciones (ProseMirror, TipTap, etc.), documentación detallada. Hocuspocus es mantenido activamente por el equipo de TipTap con buen soporte en su Discord/GitHub. Muchas empresas ya lo usan (ex. Vowel para notas colaborativas ￼). MIT licensed, sin vendor lock-in.	Liveblocks es respaldado por una empresa startup: buen soporte oficial (Slack/Discord para clientes), docs y ejemplos abundantes. Comunidad de código abierto limitada (no es un proyecto OSS para contribuir en core, aunque hay cierto ecosistema de ejemplos). Riesgo de lock-in: si Liveblocks cambiara planes o servicio, migrar sería trabajo. Pero la empresa parece estable y con clientes.	PartyKit es relativamente nuevo pero ganando adopción, se integró a Cloudflare (lo que asegura continuidad y recursos). Comunidad pequeña pero muy entusiasta, con participación de su creador (Sunil Pai) y early adopters en Discord. Automerge tiene una comunidad tech (academia, Ink&Switch) pero menos asistencia mainstream. Documentación Automerge buena (papers, readme) pero menos guías prácticas. PartyKit docs son excelentes y el hecho de que Cloudflare lo impulse es una señal de futuro promisorio. En suma, más riesgo que Yjs pero con respaldo notable.
Costo	Mantener tu propio servidor Hocuspocus: si es un pequeño instance (puede correr donde Node corre, incluso serverless websockets en Deno Deploy). Costos de infraestructura son los tuyos – en Supabase ya tienes DB, el WS server añade costo de VM o container. Para pocos usuarios, podría caber en un free tier de Heroku/Render. En general, costo = recursos cloud usados (que controlas). El software en sí es gratis (OSS).	Modelo SaaS: Free tier hasta 200 usuarios activos/mes. Luego $99/mes (2500 MAU) o planes superiores ￼. Debes evaluar según tu base de usuarios. Incluye todo el networking, storage y support en ese costo, lo cual puede compensar vs desarrollar infra. Pero a largo plazo, puede ser caro si tu app crece (ej. 10k MAU = custom plan).	PartyKit actualmente es gratuito para proyectos personales desplegando en su plataforma (con limitaciones de almacenamiento) ￼. Para uso comercial, la idea es desplegar en tu cuenta Cloudflare: PartyKit en sí es open source, no te cobran por usarlo, solo pagas a Cloudflare por las requests/DOs. Cloudflare Workers pricing es generoso (millones de requests gratis tier), probablemente el costo sea bajo para cientos de concurrentes. Es una solución muy económica comparada con Liveblocks, asumiendo puedes invertir en desarrollo en vez de suscripción.

En la tabla anterior, se observa que cada alternativa tiene fortalezas distintas. Yjs+Hocuspocus sobresale en control, rendimiento y alineación con nuestro stack existente; Liveblocks en simplicidad y rapidez de integración; Automerge+PartyKit en flexibilidad y arquitectura moderna en la edge.

Recomendaciones para el stack React Flow + Supabase

Considerando todo el análisis, a continuación se presentan recomendaciones claras para implementar la colaboración en tiempo real estilo Figma en nuestro contexto específico:
	•	Elección principal – Yjs con backend personalizado (Hocuspocus o PartyKit): Si el objetivo es tener una solución robusta, auto-hosteada y profundamente integrada con Supabase, la combinación de Yjs para la lógica colaborativa y un servidor dedicado para sincronización es la mejor apuesta. En particular, Yjs + Hocuspocus es una solución probada que cumple con todos los requisitos:
	•	Yjs ofrece sincronización inmediata y sin conflictos de la estructura del diagrama (nodos, edges, posiciones, etc.) gracias a su algoritmo CRDT eficiente ￼. Soporta casos complejos de concurrencia mejor que cualquier enfoque manual.
	•	Con Hocuspocus podemos gestionar la presencia de usuarios (cursosres remotos, selecciones compartidas) de forma nativa ￼, simplemente aprovechando Yjs Awareness. Esto nos permite replicar las características de Figma (avatares que se mueven junto al cursor, indicación de qué elemento está seleccionado por quién, etc.) con un mínimo esfuerzo de implementación en la capa de interfaz.
	•	La integración con Supabase Auth es directa: podemos reutilizar los tokens JWT emitidos por Supabase para asegurar que solo usuarios autenticados accedan a los documentos colaborativos ￼. Incluso es posible implementar controles de acceso a nivel documento usando las políticas de RLS en Postgres combinadas con la lógica del servidor (como mostró Emergence Engineering) ￼ ￼.
	•	La persistencia se realiza cómodamente en Supabase Postgres guardando el documento Yjs en binario ￼ ￼, lo que asegura que todos los datos permanezcan en nuestra base de datos (cumpliendo con cualquier requerimiento de almacenamiento interno, backups, etc.). Esto evita dependencias externas para conservar el estado.
	•	Yjs/Hocuspocus es open source y gratuito, con una amplia comunidad y soporte. No tendremos que incurrir en costes por usuario al escalar, solo costear la infraestructura en la que corramos Hocuspocus (que en muchos casos puede ser modesta, dado que Yjs es ligero). Tenemos además independencia tecnológica a largo plazo.
	•	En rendimiento, Yjs nos da confianza para manejar múltiples usuarios simultáneos editando el grafo. Su uso en casos productivos similares (herramientas de diagrama y editores concurrentes) respalda su fiabilidad ￼. Es destacable que React Flow en su propia documentación profesional recurre a Yjs para colaboración, lo que valida que es un fit natural para este stack.
Por todo ello, se recomienda implementar la colaboración con Yjs. Concretamente, se puede comenzar usando Hocuspocus como servidor de sincronización por su facilidad de uso; montar un pequeño servicio Node.js (o Deno) que corra Hocuspocus y conectarlo con Supabase según ejemplos existentes. En caso de querer aprovechar la arquitectura sin servidor, también es factible usar Y-PartyKit para desplegar el servidor Yjs en Cloudflare – pero inicialmente Hocuspocus será más sencillo de integrar y depurar, ya que hay más referencias. En ambos casos, la funcionalidad final para el usuario será la misma.
Vale la pena mencionar que, aunque Yjs es la recomendación principal, no se debe subestimar el trabajo de integración en el frontend: habrá que refactorizar cómo React Flow obtiene su estado de nodos/edges (para que venga del doc Yjs) y asegurar que las actualizaciones entrantes se reflejen. Afortunadamente, herramientas como React Flow están preparadas para estado controlado, y con Yjs podemos implementar un hook custom que actúe como store central. Este esfuerzo de desarrollo es manejable y los beneficios en experiencia colaborativa valen la pena.
	•	Alternativa SaaS – Liveblocks, si prima la rapidez de desarrollo: Si por restricciones de tiempo de desarrollo o tamaño del equipo se prefiere una solución casi lista para usar, Liveblocks es una alternativa sólida. En particular:
	•	Permite lograr colaboración completa (estado + presencia) con muy poco código en el frontend. Sus hooks y componentes hacen trivial cosas como mostrar cursors de colores o sincronizar la posición de un nodo en todos lados.
	•	Es ideal para un MVP o prototipo funcional rápido, donde se quiera validar la colaboración en tiempo real sin invertir mucho en infraestructura. En unos días se puede tener integrado Liveblocks con React Flow siguiendo sus ejemplos.
	•	Maneja automáticamente muchos detalles: reconexiones, almacenamiento persistente, optimizaciones de red, etc., lo que reduce la carga mental en el equipo de desarrollo.
	•	La integración con Supabase se limitaría a la parte de autenticación (emitir tokens Liveblocks asegurados desde nuestro backend supabase), lo cual no es muy complejo. Todo lo demás (distribución de cambios, almacenamiento de estado) lo lleva Liveblocks.
Sin embargo, se debe tener en cuenta el coste: si nuestro proyecto escala a muchos usuarios concurrentes o pagos, Liveblocks implicará gastos mensuales crecientes ￼. Además, la dependencia en un servicio externo puede ser una preocupación de largo plazo (por disponibilidad o políticas de datos). Aun así, Liveblocks puede ser excelente para acelerar el desarrollo inicial y ofrecer una experiencia pulida a los usuarios desde el día uno. Podría incluso tomarse como una solución intermedia: arrancar con Liveblocks para velocidad y, si en el futuro se desea migrar a una solución propia (Yjs), planear esa transición cuando el producto esté validado.
	•	Alternativa personalizada edge – Automerge/PartyKit, solo para casos específicos: En general, para el caso de uso de diagramas colaborativos con Supabase, Automerge + PartyKit no ofrece ventajas claras sobre Yjs/Hocuspocus. Requeriría más trabajo implementar cosas que Yjs ya resuelve (p. ej. conversión de modelo de datos, mensajes de sync). Y si quisiéramos aprovechar la edge de Cloudflare, podemos usar Yjs en PartyKit igualmente. Por tanto, no recomendamos Automerge sobre Yjs a menos que exista un motivo particular:
	•	Un motivo podría ser preferir la trayectoria offline-first de Automerge, es decir, que la aplicación funcione sin conexión y sincronice cuando pueda. Automerge se presta un poco más a esa filosofía (por su historial completo), aunque Yjs también puede usarse offline guardando updates.
	•	Otro motivo podría ser querer implementar comportamientos de servidor muy custom en PartyKit que vayan más allá de la sincronización (por ej., lógica de negocio en tiempo real, bots, etc.). PartyKit es una gran plataforma si se quiere hacer algo más complejo en el backend colaborativo. Pero para simplemente sincronizar un doc, es un nivel extra de complejidad que quizá no necesitamos si Yjs ya nos da todo.
En caso de contar con un equipo muy experimentado en CRDTs que desee explorar Automerge v2, se podría intentar esta vía, pero hay que ser conscientes de los riesgos: Yjs actualmente tiene mejores referencias en aplicaciones de producción donde se requiere rendimiento máximo ￼. A menos que se necesite alguna característica única de Automerge (como mantener todos los pasos de edición para un timeline histórico), es más seguro apostar por Yjs.
	•	Otras menciones: No se recomienda basar la colaboración únicamente en Supabase Realtime o en soluciones no especializadas en conflictos (p. ej. solo usar sockets y last-write-wins), porque se estaría reinventando la rueda y es probable encontrar problemas de consistencia difíciles de resolver. Dado que existen librerías CRDT muy eficientes, conviene usarlas. Tampoco parece necesario adoptar frameworks mucho más pesados como Fluid Framework para este escenario – sería añadir complejidad sin clara ganancia.

En conclusión, para implementar funciones colaborativas avanzadas tipo Figma sobre React Flow + Supabase, la mejor solución en términos de equilibrio entre esfuerzo y beneficios es integrar Yjs como capa de estado colaborativo. Esto puede hacerse montando un servidor Hocuspocus o incluso adaptándolo a la plataforma que prefiramos (el stack Supabase puede complementarse con una pequeña instancia Node para Hocuspocus, o Cloudflare via PartyKit). Con Yjs obtendremos un núcleo de datos eventualmente consistente altamente confiable ￼, que unido a la simplicidad de React Flow para renderizar nodos, nos permitirá ofrecer a los usuarios finales una experiencia fluida: verán en tiempo real las acciones de los demás, con cursores coloridos moviéndose por el canvas y cambios instantáneos en el diagrama sin choque de versiones. Todo ello con la tranquilidad de que el estado se guarda en Supabase y de que podemos escalar la solución sin costes ocultos.

Como apoyo a esta recomendación, recordemos que expertos en la materia ya han señalado que Yjs es una solución idónea para editores diagramáticos colaborativos (Synergy Codes indica: “recomendamos encarecidamente Yjs para colaboración multi-usuario en tiempo real… es flexible, ligera, probada en producción” ￼). Además, disponemos de ejemplos concretos (React Flow Pro, demo de Synergy Codes) que validan la viabilidad técnica de Yjs en este contexto.

Implementando Yjs, complementado con Supabase para identidad y almacenamiento, estaremos construyendo una plataforma de colaboración en tiempo real moderna, escalable y mantenible, muy en línea con lo que ofrecen aplicaciones líderes como Figma – pero adaptada a nuestras necesidades y con control total sobre nuestros datos y backend.

Referencias: Hemos basado estas conclusiones en documentación y casos de uso reales, como la guía de Synergy Codes sobre Yjs en React Flow ￼ ￼, la documentación de Liveblocks sobre presencia y almacenamiento ￼ ￼, comparativas de rendimiento entre CRDTs ￼, y experiencias de integración con Supabase ￼ ￼, entre otras fuentes. Estas confirman tanto la capacidad de cada solución como los aspectos a tener en cuenta en la implementación. En suma, con la estrategia recomendada (Yjs + Supabase + React Flow), disponemos de una hoja de ruta respaldada por la comunidad técnica para lograr colaboración en tiempo real avanzada de manera exitosa.